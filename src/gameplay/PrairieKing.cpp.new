// CowboyMonster implementation
CowboyMonster::CowboyMonster(AssetManager& assets, int which, int health, int speed, Vector2 position) {
    this->health = health;
    this->type = which;
    this->speed = speed;
    this->position = {position.x, position.y, static_cast<float>(BASE_TILE_SIZE * PIXEL_ZOOM), static_cast<float>(BASE_TILE_SIZE * PIXEL_ZOOM)};
    this->uninterested = (GetRandomFloat(0, 1) < 0.25f);
    this->tint = WHITE;
    this->flashColor = RED;
    this->flashColorTimer = 0;
    this->ticksSinceLastMovement = 0;
    this->acceleration = {0, 0};
    this->targetPosition = {0, 0};
    this->gameInstance = PrairieKing::GetGameInstance();
}

CowboyMonster::CowboyMonster(AssetManager& assets, int which, Vector2 position) {
    this->type = which;
    this->position = {position.x, position.y, static_cast<float>(BASE_TILE_SIZE * PIXEL_ZOOM), static_cast<float>(BASE_TILE_SIZE * PIXEL_ZOOM)};
    
    switch (type) {
        case GameConstants::ORC:
            speed = GameConstants::ORC_SPEED;
            health = GameConstants::ORC_HEALTH;
            uninterested = (GetRandomFloat(0, 1) < 0.25f);
            if (uninterested) {
                targetPosition = {
                    GetRandomFloat(2, 14) * BASE_TILE_SIZE * PIXEL_ZOOM,
                    GetRandomFloat(2, 14) * BASE_TILE_SIZE * PIXEL_ZOOM
                };
            }
            break;
        case GameConstants::OGRE:
            speed = GameConstants::OGRE_SPEED;
            health = GameConstants::OGRE_HEALTH;
            break;
        case GameConstants::MUSHROOM:
            speed = GameConstants::SPIKEY_SPEED;
            health = GameConstants::SPIKEY_HEALTH;
            break;
        case GameConstants::GHOST:
            speed = GameConstants::GHOST_SPEED;
            health = GameConstants::GHOST_HEALTH;
            flyer = true;
            break;
        case GameConstants::MUMMY:
            health = 6;
            speed = 1;
            uninterested = (GetRandomFloat(0, 1) < 0.25f);
            if (uninterested) {
                targetPosition = {
                    GetRandomFloat(2, 14) * BASE_TILE_SIZE * PIXEL_ZOOM,
                    GetRandomFloat(2, 14) * BASE_TILE_SIZE * PIXEL_ZOOM
                };
            }
            break;
        case GameConstants::DEVIL:
            health = 3;
            speed = 3;
            flyer = true;
            break;
        case GameConstants::SPIKEY:
            speed = GameConstants::SPIKEY_SPEED;
            health = GameConstants::SPIKEY_HEALTH;
            int tries = 0;
            do {
                targetPosition = {
                    GetRandomFloat(2, 14) * BASE_TILE_SIZE * PIXEL_ZOOM,
                    GetRandomFloat(2, 14) * BASE_TILE_SIZE * PIXEL_ZOOM
                };
                tries++;
            } while (gameInstance->IsCollidingWithMapForMonsters({targetPosition.x, targetPosition.y, 
                   static_cast<float>(BASE_TILE_SIZE * PIXEL_ZOOM), static_cast<float>(BASE_TILE_SIZE * PIXEL_ZOOM)}) && tries < 10);
            break;
    }
    
    oppositeMotionGuy = (GetRandomFloat(0, 1) < 0.5f);
    this->tint = WHITE;
    this->flashColor = RED;
    this->flashColorTimer = 0;
    this->ticksSinceLastMovement = 0;
    this->acceleration = {0, 0};
    this->gameInstance = PrairieKing::GetGameInstance();
}

void CowboyMonster::Draw(const Texture2D& texture, Vector2 topLeftScreenCoordinate) {
    Rectangle destRect = {
        topLeftScreenCoordinate.x + position.x,
        topLeftScreenCoordinate.y + position.y,
        position.width,
        position.height
    };
    
    Color drawColor = (flashColorTimer > 0) ? flashColor : tint;
    DrawTexturePro(texture, {0, 0, 16, 16}, destRect, {0, 0}, 0, drawColor);
}

bool CowboyMonster::TakeDamage(int damage) {
    health -= damage;
    if (health <= 0) {
        return true;
    }
    flashColorTimer = 100.0f;
    PlaySound(PrairieKing::GetSoundStatic("cowboy_monsterhit"));
    return false;
}

int CowboyMonster::GetLootDrop() {
    if (GetRandomFloat(0, 1) < GameConstants::LOOT_CHANCE) {
        return static_cast<int>(GetRandomFloat(0, 10));
    }
    return -1;
}

bool CowboyMonster::Move(Vector2 playerPosition, float deltaTime) {
    if (flashColorTimer > 0) {
        flashColorTimer -= deltaTime * 1000;
    }
    
    if (uninterested && targetPosition.x == 0 && targetPosition.y == 0) {
        return false;
    }
    
    Vector2 target = uninterested ? targetPosition : playerPosition;
    Vector2 currentPos = {position.x, position.y};
    Vector2 direction = {
        target.x - currentPos.x,
        target.y - currentPos.y
    };
    
    float length = sqrt(direction.x * direction.x + direction.y * direction.y);
    if (length > 0) {
        direction.x /= length;
        direction.y /= length;
    }
    
    Vector2 attemptedPosition = {
        position.x + direction.x * speed,
        position.y + direction.y * speed
    };
    
    Rectangle attemptedRect = {
        attemptedPosition.x,
        attemptedPosition.y,
        position.width,
        position.height
    };
    
    if (!gameInstance->IsCollidingWithMapForMonsters(attemptedRect) && 
        !gameInstance->IsCollidingWithMonster(attemptedRect, this)) {
        position = attemptedRect;
        movedLastTurn = true;
        ticksSinceLastMovement = 0;
        
        if (uninterested && 
            abs(position.x - targetPosition.x) < speed && 
            abs(position.y - targetPosition.y) < speed) {
            targetPosition = {0, 0};
            if (GetRandomFloat(0, 1) < 0.5f) {
                uninterested = false;
            }
        }
        return true;
    }
    
    ticksSinceLastMovement++;
    movedLastTurn = false;
    return false;
}

void CowboyMonster::SpikeyEndBehavior(int extraInfo) {
    invisible = false;
    health += 5;
    special = true;
}

// Dracula implementation
Dracula::Dracula(AssetManager& assets) : CowboyMonster(assets, -2, 350, 2, {8 * BASE_TILE_SIZE * PIXEL_ZOOM, 8 * BASE_TILE_SIZE * PIXEL_ZOOM}) {
    homePosition = {position.x, position.y};
    position.y += BASE_TILE_SIZE * PIXEL_ZOOM * 4;
    fullHealth = health;
    phase = GLOATING_PHASE;
    phaseInternalTimer = 4000;
}

void Dracula::Draw(const Texture2D& texture, Vector2 topLeftScreenCoordinate) {
    Rectangle destRect = {
        topLeftScreenCoordinate.x + position.x,
        topLeftScreenCoordinate.y + position.y,
        position.width,
        position.height
    };
    
    Color drawColor = (flashColorTimer > 0) ? flashColor : tint;
    DrawTexturePro(texture, {16, 0, 16, 16}, destRect, {0, 0}, 0, drawColor);
}

int Dracula::GetLootDrop() {
    return POWERUP_HEART;
}

bool Dracula::TakeDamage(int damage) {
    if (phase == GLOATING_PHASE) {
        return false;
    }
    health -= damage;
    if (health <= 0) {
        return true;
    }
    flashColorTimer = 100.0f;
    PlaySound(PrairieKing::GetSoundStatic("cowboy_monsterhit"));
    return false;
}

bool Dracula::Move(Vector2 playerPosition, float deltaTime) {
    if (flashColorTimer > 0) {
        flashColorTimer -= deltaTime * 1000;
    }
    
    phaseInternalTimer -= deltaTime * 1000;
    
    switch (phase) {
        case GLOATING_PHASE:
            if (phaseInternalTimer <= 0) {
                phaseInternalCounter = 0;
                PlaySound(PrairieKing::GetSoundStatic("cowboy_boss"));
                phase = WALK_RANDOMLY_AND_SHOOT_PHASE;
            }
            break;
            
        case WALK_RANDOMLY_AND_SHOOT_PHASE:
            if (phaseInternalTimer <= 0) {
                phaseInternalCounter++;
                if (phaseInternalCounter >= 3) {
                    phase = SPREAD_SHOT_PHASE;
                    phaseInternalTimer = 2000;
                } else {
                    phaseInternalTimer = 2000;
                    FireSpread({position.x, position.y}, 0);
                }
            } else {
                CowboyMonster::Move(playerPosition, deltaTime);
            }
            break;
            
        case SPREAD_SHOT_PHASE:
            if (phaseInternalTimer <= 0) {
                phase = SUMMON_DEMON_PHASE;
                phaseInternalTimer = 3000;
            } else {
                FireSpread({position.x, position.y}, phaseInternalTimer / 2000.0 * PI);
            }
            break;
            
        case SUMMON_DEMON_PHASE:
            if (phaseInternalTimer <= 0) {
                SummonEnemies({position.x, position.y}, DEVIL);
                phase = SUMMON_MUMMY_PHASE;
                phaseInternalTimer = 3000;
            }
            break;
            
        case SUMMON_MUMMY_PHASE:
            if (phaseInternalTimer <= 0) {
                SummonEnemies({position.x, position.y}, MUMMY);
                phase = WALK_RANDOMLY_AND_SHOOT_PHASE;
                phaseInternalTimer = 2000;
            }
            break;
    }
    
    return false;
}

void Dracula::FireSpread(Vector2 origin, double offsetAngle) {
    for (int i = 0; i < 8; i++) {
        double angle = (i * PI / 4) + offsetAngle;
        Vector2 direction = {
            static_cast<float>(cos(angle)),
            static_cast<float>(sin(angle))
        };
        
        Vector2 bulletSpawn = {
            origin.x + direction.x * BASE_TILE_SIZE * PIXEL_ZOOM,
            origin.y + direction.y * BASE_TILE_SIZE * PIXEL_ZOOM
        };
        
        gameInstance->SpawnBullets({static_cast<int>(angle * 4 / PI)}, bulletSpawn);
    }
}

void Dracula::SummonEnemies(Vector2 origin, int which) {
    Vector2 spawnPoints[] = {
        {origin.x - BASE_TILE_SIZE * PIXEL_ZOOM * 1.5f, origin.y},
        {origin.x + BASE_TILE_SIZE * PIXEL_ZOOM * 1.5f, origin.y},
        {origin.x, origin.y + BASE_TILE_SIZE * PIXEL_ZOOM * 1.5f},
        {origin.x, origin.y - BASE_TILE_SIZE * PIXEL_ZOOM * 2.25f}
    };
    
    for (const auto& spawnPoint : spawnPoints) {
        Rectangle spawnRect = {
            spawnPoint.x,
            spawnPoint.y,
            static_cast<float>(BASE_TILE_SIZE * PIXEL_ZOOM),
            static_cast<float>(BASE_TILE_SIZE * PIXEL_ZOOM)
        };
        
        if (!gameInstance->IsCollidingWithMonster(spawnRect, nullptr)) {
            gameInstance->AddMonster(new CowboyMonster(gameInstance->GetAssetManager(), which, spawnPoint));
        }
    }
    
    PlaySound(PrairieKing::GetSoundStatic("Cowboy_monsterDie"));
}

// Outlaw implementation
Outlaw::Outlaw(AssetManager& assets, Vector2 position, int health) 
    : CowboyMonster(assets, -1, health, 2, position) {
    homePosition = position;
    fullHealth = health;
    phaseCountdown = 4000;
    phase = TALKING_PHASE;
}

void Outlaw::Draw(const Texture2D& texture, Vector2 topLeftScreenCoordinate) {
    Rectangle destRect = {
        topLeftScreenCoordinate.x + position.x,
        topLeftScreenCoordinate.y + position.y,
        position.width,
        position.height
    };
    
    Color drawColor = (flashColorTimer > 0) ? flashColor : tint;
    DrawTexturePro(texture, {32, 0, 16, 16}, destRect, {0, 0}, 0, drawColor);
}

bool Outlaw::Move(Vector2 playerPosition, float deltaTime) {
    if (flashColorTimer > 0) {
        flashColorTimer -= deltaTime * 1000;
    }
    
    phaseCountdown -= deltaTime * 1000;
    
    switch (phase) {
        case TALKING_PHASE:
            if (phaseCountdown <= 0) {
                phase = HIDING_PHASE;
                phaseCountdown = 2000;
            }
            break;
            
        case HIDING_PHASE:
            if (phaseCountdown <= 0) {
                phase = DART_OUT_AND_SHOOT_PHASE;
                dartLeft = (GetRandomFloat(0, 1) < 0.5f);
                phaseCountdown = 1000;
            }
            break;
            
        case DART_OUT_AND_SHOOT_PHASE:
            if (phaseCountdown <= 0) {
                phase = RUN_AND_GUN_PHASE;
                phaseCountdown = 3000;
            } else {
                Vector2 moveDirection = dartLeft ? Vector2{-1, 0} : Vector2{1, 0};
                position.x += moveDirection.x * speed;
                if (shootTimer <= 0) {
                    gameInstance->SpawnBullets({dartLeft ? 3 : 1}, {position.x, position.y});
                    shootTimer = 500;
                }
                shootTimer -= deltaTime * 1000;
            }
            break;
            
        case RUN_AND_GUN_PHASE:
            if (phaseCountdown <= 0) {
                phase = RUN_GUN_AND_PANT_PHASE;
                phaseCountdown = 2000;
            } else {
                Vector2 moveDirection = dartLeft ? Vector2{-1, 0} : Vector2{1, 0};
                position.x += moveDirection.x * speed;
                if (shootTimer <= 0) {
                    gameInstance->SpawnBullets({dartLeft ? 3 : 1}, {position.x, position.y});
                    shootTimer = 300;
                }
                shootTimer -= deltaTime * 1000;
            }
            break;
            
        case RUN_GUN_AND_PANT_PHASE:
            if (phaseCountdown <= 0) {
                phase = SHOOT_AT_PLAYER_PHASE;
                phaseCountdown = 2000;
            }
            break;
            
        case SHOOT_AT_PLAYER_PHASE:
            if (phaseCountdown <= 0) {
                phase = HIDING_PHASE;
                phaseCountdown = 2000;
            } else {
                if (shootTimer <= 0) {
                    Vector2 direction = {
                        playerPosition.x - position.x,
                        playerPosition.y - position.y
                    };
                    float length = sqrt(direction.x * direction.x + direction.y * direction.y);
                    if (length > 0) {
                        direction.x /= length;
                        direction.y /= length;
                    }
                    gameInstance->SpawnBullets({static_cast<int>(atan2(direction.y, direction.x) * 2 / PI)}, {position.x, position.y});
                    shootTimer = 500;
                }
                shootTimer -= deltaTime * 1000;
            }
            break;
    }
    
    return false;
}

int Outlaw::GetLootDrop() {
    return POWERUP_SHERRIFF;
}

bool Outlaw::TakeDamage(int damage) {
    if (phase == TALKING_PHASE) {
        return false;
    }
    health -= damage;
    if (health <= 0) {
        return true;
    }
    flashColorTimer = 100.0f;
    PlaySound(PrairieKing::GetSoundStatic("cowboy_monsterhit"));
    return false;
} 